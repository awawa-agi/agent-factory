"""
Prompt formatting utilities for agent factory rollout system.

This module contains functions for formatting prompts, particularly for 
function calling system messages and tool parameter extraction.
"""

from typing import List, Dict, Any, Optional
from ..messages import Messages, SystemMessage, TextContent


def extract_tool_parameters(input_schema: Dict[str, Any]) -> Dict[str, Any]:
    """Extract and format tool parameters from tool metadata
    
    Args:
        input_schema: Tool metadata dictionary containing inputSchema
        
    Returns:
        dict: Formatted parameter dictionary with description, type, default, and required fields
    """
    full_param_dict = {}
    requireds = input_schema.get('required', [])
    
    for param_name, param_schema in input_schema['properties'].items():
        param_dict = {}
        
        # Extract parameter information
        if 'description' in param_schema:
            param_dict['description'] = param_schema['description']
        if 'type' in param_schema:
            param_dict['type'] = param_schema['type']
        if 'default' in param_schema:
            param_dict['default'] = param_schema['default']
        
        param_dict['required'] = param_name in requireds
        full_param_dict[param_name] = param_dict
    
    return full_param_dict

def build_tool_system_message(
    tools_meta: List[Dict[str, Any]],
    max_num_tool_calls_per_round: int,
    multimodal_prompt: bool,
) -> str:
    """Build function calling content from tools"""

    tool_desc = '\n\n'.join(f"""<function>
<name>{t['name']}</name>
<description>{t['description']}</description>
<parameters>{extract_tool_parameters(t['inputSchema'])}</parameters>
<max_calls>{t['usage']['max_calls']}</max_calls>
</function>""" for t in tools_meta)
    
    if  max_num_tool_calls_per_round > 1:
        calling_desc = """\n\nIn this environment you have access to a set of tools you can use to answer the user's question.
You can invoke functions by writing a "<afml:function_calls>" block like the following as part of your reply to the user:

<afml:function_calls>
<afml:invoke name="$FUNCTION_NAME">
<afml:parameter name="$PARAMETER_NAME">$PARAMETER_VALUE</afml:parameter>
...
</afml:invoke>
<afml:invoke name="$FUNCTION_NAME2">
...
</afml:invoke>
</afml:function_calls>

String and scalar parameters should be specified as is, while lists and objects should use JSON format.

If you intend to call multiple tools and there are no dependencies between the calls, make all of the independent calls in the same <afml:function_calls></afml:function_calls> block.
"""
    else:
        calling_desc = """\n\nIn this environment you have access to a set of tools you can use to answer the user's question.
You can invoke functions by writing a "<afml:function_calls>" block like the following as part of your reply to the user:

<afml:function_calls>
<afml:invoke name="$FUNCTION_NAME">
<afml:parameter name="$PARAMETER_NAME">$PARAMETER_VALUE</afml:parameter>
...
</afml:invoke>
</afml:function_calls>

String and scalar parameters should be specified as is, while lists and objects should use JSON format.

You can only invoke one tool at a time in each function call block."""

    if multimodal_prompt:
        image_processing_desc = """Regarding image processing:
Images submitted by users or generated by tools will be automatically resized and presented in the following format:
<image path=... display_size=WxH>

While display images are downsampled to optimize computational resources, you will maintain access to the original full-resolution images when operating within the tool environment. This ensures efficient display while preserving complete image data for any analytical or processing tasks you perform."""
    else:
        image_processing_desc = ""
    
    full_desc = f"""
{calling_desc}

Here are the functions available:
<functions>
{tool_desc}
</functions>

{image_processing_desc}
"""
    return full_desc

# ------- Message Processing -------
def add_function_calling_system(
    messages: Messages, 
    tools_meta: Optional[List[Dict[str, Any]]] = None,
    max_num_tool_calls_per_round: int = 1,
    multimodal_prompt: bool = True,
) -> Messages:
    """Add function calling system message if tools are available.
    
    Args:
        messages: The messages to modify
        tools_meta: Optional list of tool metadata
        
    Returns:
        Messages: Modified messages with function calling system message added
    """
    if tools_meta: 
        fc_content = build_tool_system_message(
            tools_meta,
            max_num_tool_calls_per_round,
            multimodal_prompt,
        )
        
        # Check if system message already exists
        if messages[0].role == "system":
            # Since content is frozen, we need to create new content list
            new_content = list(messages[0].content) + [TextContent(text=fc_content)]
            messages[0] = messages[0].update_content(new_content)  
        else:
            system_msg = SystemMessage(content=[TextContent(text=fc_content)])
            messages.insert(0, system_msg)

    return messages 